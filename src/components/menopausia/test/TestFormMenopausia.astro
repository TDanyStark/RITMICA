---
import { condicionesMenopausia as criterios } from "@/data/DataMenopausia";
// import { testScenarios } from "./test-scenarios";
import FixedResultMenopausia from "./FixedResultMenopausia.astro";
---

<div
  class="w-full max-w-4xl mx-auto px-2 md:px-4 mb-2 relative flex items-center gap-2"
>
  <div class="relative flex-1">
    <input
      type="text"
      id="search-input"
      placeholder="Buscar criterio..."
      class="w-full py-3 px-6 pr-12 rounded-xl md:rounded-full border-2 border-purple-abbott text-purple-abbott placeholder-purple-abbott/50 focus:outline-none focus:bg-white/50 bg-white/90 shadow-sm text-xl transition-all"
    />
    <button
      id="clear-search"
      class="absolute right-4 top-1/2 -translate-y-1/2 text-purple-abbott hover:text-purple-900 transition-colors hidden"
      aria-label="Borrar búsqueda"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M6 18L18 6M6 6l12 12"></path>
      </svg>
    </button>
  </div>
  <button
    id="toggle-all-btn"
    class="bg-white/90 text-purple-abbott p-3 rounded-full shadow-sm border-2 border-purple-abbott hover:bg-purple-abbott hover:text-white transition-all"
    aria-label="Expandir/Colapsar todo"
    title="Expandir/Colapsar todo"
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="h-6 w-6"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
      ></path>
    </svg>
  </button>
</div>

<div
  id="form-container"
  class="flex flex-col gap-4 w-full max-w-4xl mx-auto p-2 md:p-4 md:px-10"
>
  <!-- Rendered via JS -->
</div>

<FixedResultMenopausia />

<script is:inline data-astro-rerun define:vars={{ criterios }}>
  document.addEventListener(
    "astro:page-load",
    () => {
      const container = document.getElementById("form-container");
      if (!container) return;
      const searchInput = document.getElementById("search-input");
      const clearSearchBtn = document.getElementById("clear-search");
      let formState = {};

      // Unificado: mapa de métodos -> nombre legible. Usar `Object.keys(METHOD_MAP)`
      // cuando se necesite la lista de métodos.
      const METHOD_MAP = {
        "THM combinada oral": "THM combinada oral",
        "THM combinada trans": "THM combinada trans",
        "THM solo estrógeno oral": "THM solo estrógeno oral",
        "THM solo estrógeno trans": "THM solo estrógeno trans",
        "Tibolona": "Tibolona",
        "THM local": "THM local"
      };

      const SUMMARY_LABELS = {
        "THM combinada oral": "Comb. Oral",
        "THM combinada trans": "Comb. Trans",
        "THM solo estrógeno oral": "Est. Oral",
        "THM solo estrógeno trans": "Est.Trans",
        "Tibolona": "Tibolona",
        "THM local": "THM local"
      };



      function filterNodes(nodes, term) {
        if (!term) return nodes;

        return nodes
          .map((node) => {
            const labelMatch = node.label
              .toLowerCase()
              .includes(term.toLowerCase());

            if (node.children) {
              const filteredChildren = filterNodes(node.children, term);
              const hasMatchingChild = filteredChildren.length > 0;

              if (labelMatch) {
                // Match on this category: Return it with ALL children (original), expanded
                return { ...node, _forceOpen: true };
              } else if (hasMatchingChild) {
                // Match in descendants: Return with filtered children, expanded
                return {
                  ...node,
                  children: filteredChildren,
                  _forceOpen: true,
                };
              }
            } else {
              // Leaf node
              if (labelMatch) return node;
            }
            return null;
          })
          .filter((n) => n !== null);
      }

      function createButton(label, id, isExpanded) {
        const btn = document.createElement("button");
        btn.className =
          "accordion-trigger menu-btn bg-white/90 text-purple-abbott rounded-xl md:rounded-full py-4 px-8 text-left text-xl md:text-2xl uppercase shadow-md hover:text-white hover:font-bold hover:scale-[1.02] hover:bg-purple-abbott transition-all w-full flex justify-between items-center";
        btn.id = id;

        const spanLabel = document.createElement("span");
        spanLabel.textContent = label;

        const spanIcon = document.createElement("span");
        spanIcon.className = "icon text-2xl transition-transform duration-300";
        spanIcon.textContent = "▼";
        if (isExpanded) spanIcon.style.transform = "rotate(180deg)";

        btn.appendChild(spanLabel);
        btn.appendChild(spanIcon);

        return { btn, icon: spanIcon };
      }

      function createInputRow(node, path, type, groupName) {
        const label = document.createElement("label");
        label.className =
          "text-white  md:text-purple-abbott py-2 px-8 text-left text-xl md:text-2xl uppercase w-full flex items-start gap-4 cursor-pointer group transition-opacity hover:opacity-75";

        const inputContainer = document.createElement("div");
        inputContainer.className = "relative flex items-center mt-1";

        const input = document.createElement("input");
        input.type = type;
        input.className =
          "peer h-6 w-6 min-w-[1.5rem] cursor-pointer appearance-none border-2 border-white md:border-purple-abbott checked:bg-purple-abbott transition-all bg-transparent";

        if (type === "checkbox") {
          input.classList.add("rounded");
        } else {
          input.classList.add("rounded-full");
        }

        input.name = groupName || path; // Group name for radios, path for checkbox
        input.value = JSON.stringify(node.values || {});
        input.dataset.path = path;

        const indicator = document.createElement("div");
        indicator.className =
          "absolute inset-0 flex items-center justify-center pointer-events-none opacity-0 peer-checked:opacity-100 transition-opacity";

        if (type === "radio") {
          // Inner circle for radio
          const dot = document.createElement("div");
          dot.className = "w-2.5 h-2.5 bg-white rounded-full";
          indicator.appendChild(dot);
        } else {
          // Checkmark for checkbox
          indicator.innerHTML = `<svg class="w-4 h-4 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12" /></svg>`;
        }

        inputContainer.appendChild(input);
        inputContainer.appendChild(indicator);

        const textSpan = document.createElement("span");
        textSpan.className = "flex-1 leading-tight";
        textSpan.textContent = node.label;

        label.appendChild(inputContainer);
        label.appendChild(textSpan);

        // Event Listener
        input.addEventListener("change", (e) => {
          const target = e.target;
          let val = {};
          try {
            val = JSON.parse(target.value);
          } catch (err) {}

          if (type === "radio") {
            formState[groupName] = {
              path: path,
              values: val,
              type: "radio",
              label: node.label,
            };
          } else {
            if (target.checked) {
              formState[path] = {
                values: val,
                type: "checkbox",
                label: node.label,
              };
            } else {
              delete formState[path];
            }
          }
          // console.log("Form State:", formState);
          updateDrawer();
        });

        return label;
      }

      function renderNodes(nodes, parentContainer, parentPath = "", level = 0, parentNode = null) {
        if (!nodes) return;
        const isGroupRadio = parentNode && parentNode.isgroup;
        const groupName = isGroupRadio ? `group-${parentPath}` : null;

        nodes.forEach((node, index) => {
          const currentPath = parentPath
            ? `${parentPath}-${index}`
            : `${index}`;

          // Case 1: Node is a Group (has children)
          if (node.children) {
            const wrapper = document.createElement("div");
            wrapper.className = "w-full flex flex-col gap-4"; // Added gap for spacing

            const { btn, icon } = createButton(
              node.label,
              `btn-${currentPath}`,
              node._forceOpen
            );

            const content = document.createElement("div");
            content.id = `content-${currentPath}`;

            // Apply border and indentation to all levels (Level 0 content = Level 1 items, etc.)
            // "linea mas pegada al contenido" -> reduced pl (pl-3)
            // "agrega un margin" -> ml-4 md:ml-8 to indent the whole block
            content.className =
              "hidden flex-col gap-3 mt-4 pl-3 border-l-2 border-purple-abbott/30 ml-4 md:ml-8";

            if (node._forceOpen) {
              content.classList.remove("hidden");
              content.classList.add("flex");
            }

            btn.onclick = (e) => {
              e.stopPropagation();
              const isHidden = content.classList.contains("hidden");
              if (isHidden) {
                content.classList.remove("hidden");
                content.classList.add("flex");
                icon.style.transform = "rotate(180deg)";
              } else {
                content.classList.add("hidden");
                content.classList.remove("flex");
                icon.style.transform = "rotate(0deg)";
              }
            };

            wrapper.appendChild(btn);
            wrapper.appendChild(content);
            parentContainer.appendChild(wrapper);

            // Recurse
            renderNodes(node.children, content, currentPath, level + 1, node);
          }
          // Case 2: Node is a Leaf (has values)
          else if (node.values) {
            const type = isGroupRadio ? "radio" : "checkbox";
            const row = createInputRow(node, currentPath, type, groupName);
            parentContainer.appendChild(row);
          }
        });
      }

      searchInput.addEventListener("input", (e) => {
        const term = e.target.value;

        if (term.length > 0) {
          clearSearchBtn.classList.remove("hidden");
        } else {
          clearSearchBtn.classList.add("hidden");
        }

        const filtered = filterNodes(criterios, term);
        container.innerHTML = ""; // Clear
        renderNodes(filtered, container);
      });

      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        clearSearchBtn.classList.add("hidden");
        container.innerHTML = "";
        renderNodes(criterios, container);
        searchInput.focus();
      });

      // Toggle All Logic
      const toggleAllBtn = document.getElementById("toggle-all-btn");

      if (toggleAllBtn) {
        toggleAllBtn.addEventListener("click", () => {
          const allContents = document.querySelectorAll('[id^="content-"]');
          // Check if ANY content is currently visible (expanded)
          const anyExpanded = Array.from(allContents).some(
            (content) => !content.classList.contains("hidden")
          );

          const triggers = document.querySelectorAll(".accordion-trigger");
          triggers.forEach((btn) => {
            const contentId = btn.id.replace("btn-", "content-");
            const content = document.getElementById(contentId);
            const icon = btn.querySelector(".icon");

            if (content && icon) {
              if (anyExpanded) {
                // Collapse All
                content.classList.add("hidden");
                content.classList.remove("flex");
                icon.style.transform = "rotate(0deg)";
              } else {
                // Expand All
                content.classList.remove("hidden");
                content.classList.add("flex");
                icon.style.transform = "rotate(180deg)";
              }
            }
          });
        });
      }

      // Reset Logic
      const resetTestBtn = document.getElementById("reset-test-btn");

      if (resetTestBtn) {
        resetTestBtn.addEventListener("click", (e) => {
          e.stopPropagation(); // Prevent drawer toggle

          // Clear state
          formState = {};

          // Clear search
          searchInput.value = "";
          clearSearchBtn.classList.add("hidden");

          // Re-render (clears inputs)
          container.innerHTML = "";
          renderNodes(criterios, container);

          // Update drawer
          updateDrawer();
        });
      }

      // Initial Render
      renderNodes(criterios, container);

      // Drawer Logic
      const drawerToggle = document.getElementById("drawer-toggle");
      const resultsDrawer = document.getElementById("results-drawer");
      const drawerIcon = document.getElementById("drawer-icon");
      const resultsSummary = document.getElementById("results-summary");

      if (drawerToggle) {
        drawerToggle.addEventListener("click", () => {
          const isClosed = resultsDrawer.classList.contains(
            "translate-y-[calc(100%-5rem)]"
          );
          if (isClosed) {
            // Open
            resultsDrawer.classList.remove("translate-y-[calc(100%-5rem)]");
            resultsDrawer.classList.add("translate-y-0");
            drawerIcon.style.transform = "rotate(180deg)";
          } else {
            // Close
            resultsDrawer.classList.remove("translate-y-0");
            resultsDrawer.classList.add("translate-y-[calc(100%-5rem)]");
            drawerIcon.style.transform = "rotate(0deg)";
          }
        });
      }

      function getBadgeColor(num) {
        switch (num) {
          case 1:
            return "bg-[#009A44]";
          case 2:
            return "bg-[#8BC53F]";
          case 3:
            return "bg-[#FDB913]";
          case 4:
            return "bg-[#E30613]";
          default:
            return "bg-gray-400";
        }
      }

      function calculateScores() {
        const methods = Object.keys(METHOD_MAP);
        const result = {};
        const selections = Object.values(formState);

        // If no selection, return null to show placeholder
        if (selections.length === 0) return null;

        methods.forEach((method) => {
          let maxI = 0;
          let maxC = 0;
          let conditionsI = [];
          let conditionsC = [];
          let hasN = false;
          let hasValue = false;

          selections.forEach((selection) => {
            const valObj = selection.values;
            const label = selection.label;
            const val = valObj[method];

            if (val === undefined) return;
            hasValue = true;

            const processVal = (v, cond, type) => {
              if (v === "N" || v === "NA") {
                hasN = true;
                return;
              }
              const numVal = Number(v);
              if (isNaN(numVal)) return;

              if (type === "I") {
                if (numVal > maxI) {
                  maxI = numVal;
                  conditionsI = cond ? [`${numVal} - ${label}: ${cond}`] : [];
                } else if (numVal === maxI && cond) {
                  conditionsI.push(`${numVal} - ${label}: ${cond}`);
                }
              } else {
                if (numVal > maxC) {
                  maxC = numVal;
                  conditionsC = cond ? [`${numVal} - ${label}: ${cond}`] : [];
                } else if (numVal === maxC && cond) {
                  conditionsC.push(`${numVal} - ${label}: ${cond}`);
                }
              }
            };

            if (val === "N" || val === "NA") {
              hasN = true;
            } else if (typeof val === "number") {
              processVal(val, null, "I");
              processVal(val, null, "C");
            } else if (typeof val === "object" && val !== null) {
              if ("C" in val && "I" in val) {
                const valI = typeof val.I === "object" ? val.I.val : val.I;
                const condI =
                  typeof val.I === "object" ? val.I.condition : null;
                processVal(valI, condI, "I");

                const valC = typeof val.C === "object" ? val.C.val : val.C;
                const condC =
                  typeof val.C === "object" ? val.C.condition : null;
                processVal(valC, condC, "C"); 
              } else if ("val" in val) {
                processVal(val.val, val.condition, "I");
                processVal(val.val, val.condition, "C");
              } else if ("condicion1" in val && "condicion2" in val) {
                const v1 = val.condicion1.val;
                const c1 = val.condicion1.condition;
                const v2 = val.condicion2.val;
                const c2 = val.condicion2.condition;
                // Map condicion1 to I slot and condicion2 to C slot to display both
                processVal(v1, c1, "I");
                processVal(v2, c2, "C");
              }
            }
          });

          if (hasN) {
            result[method] = "N";
          } else if (hasValue) {
            result[method] = {
              I: maxI || 1,
              C: maxC || 1,
              conditionsI: [...new Set(conditionsI)],
              conditionsC: [...new Set(conditionsC)],
            };
          } else {
            result[method] = { I: 1, C: 1, conditionsI: [], conditionsC: [] };
          }
        });
        return result;
      }

      function updateDrawer() {
        const scores = calculateScores();
        resultsSummary.innerHTML = "";

        const detailedResultsContainer =
          document.getElementById("detailed-results");
        if (detailedResultsContainer) detailedResultsContainer.innerHTML = "";

        const methodNames = METHOD_MAP;

        if (!scores) {
          resultsSummary.innerHTML =
            '<span class="text-gray-400 italic">Selecciona criterios para ver resultados...</span>';
          if (detailedResultsContainer) {
            detailedResultsContainer.innerHTML =
              '<p class="text-gray-500 italic text-center py-4">Selecciona criterios para ver tus resultados detallados.</p>';
          }
          return;
        }

        const sortedEntries = Object.entries(scores)
          .filter(([_, score]) => score !== "N")
          .sort((a, b) => {
            const valA = Math.max(a[1].I, a[1].C);
            const valB = Math.max(b[1].I, b[1].C);
            return valA - valB;
          });

        sortedEntries.forEach(([method, score]) => {
          const wrapper = document.createElement("div");
          wrapper.className = "flex flex-col items-center min-w-[4rem]";

          const badge = document.createElement("div");
          // Base classes
          badge.className =
            "w-10 h-10 rounded-full text-white font-bold flex items-center justify-center shadow-sm text-lg mb-1 transition-colors";

          let text = "";
          let colorClass = "";

          const fmt = (val, conds) =>
            `${val}${conds && conds.length > 0 ? "*" : ""}`;

          if (score.I === score.C) {
            const hasConditions =
              (score.conditionsI && score.conditionsI.length > 0) ||
              (score.conditionsC && score.conditionsC.length > 0);
            text = `${score.I}${hasConditions ? "*" : ""}`;
            colorClass = getBadgeColor(score.I);
          } else {
            const txtI = fmt(score.I, score.conditionsI);
            const txtC = fmt(score.C, score.conditionsC);
            text = `${txtI}|${txtC}`;
            const maxVal = Math.max(score.I, score.C);
            colorClass = getBadgeColor(maxVal);
            badge.classList.add("text-sm");
          }

          // Add color class
          // We use the exact strings that are present in the HTML to ensure Tailwind picks them up
          badge.classList.add(colorClass);

          badge.textContent = text;

          const label = document.createElement("span");
          label.className =
            "text-xs font-bold text-purple-abbott text-center leading-tight text-nowrap";
          label.textContent = SUMMARY_LABELS[method] || method;

          wrapper.appendChild(badge);
          wrapper.appendChild(label);
          resultsSummary.appendChild(wrapper);

          // Detailed Result Item
          if (detailedResultsContainer) {
            const detailRow = document.createElement("div");
            detailRow.className =
              "flex items-center gap-4 p-4 bg-white rounded-xl shadow-sm border border-gray-100";

            const detailBadge = document.createElement("div");
            detailBadge.className = `w-16 h-16 rounded-full text-white font-bold flex items-center justify-center shadow-sm text-2xl shrink-0 ${colorClass}`;
            detailBadge.textContent = text;

            const detailInfo = document.createElement("div");
            detailInfo.className = "flex flex-col";

            const detailTitle = document.createElement("span");
            detailTitle.className = "font-bold text-purple-abbott text-xl";
            detailTitle.textContent = `${method}`;

            const detailDesc = document.createElement("span");
            detailDesc.className = "text-gray-600";
            detailDesc.textContent = methodNames[method] || "";

            detailInfo.appendChild(detailTitle);
            detailInfo.appendChild(detailDesc);

            const allConditions = [
              ...new Set([...score.conditionsI, ...score.conditionsC]),
            ];
            if (allConditions.length > 0) {
              const condList = document.createElement("ul");
              condList.className =
                "text-sm text-gray-500 mt-1 list-disc list-inside";
              allConditions.forEach((c) => {
                const li = document.createElement("li");
                li.textContent = c;
                condList.appendChild(li);
              });
              detailInfo.appendChild(condList);
            }

            detailRow.appendChild(detailBadge);
            detailRow.appendChild(detailInfo);
            detailedResultsContainer.appendChild(detailRow);
          }
        });
      }
    },
    { once: true }
  );
</script>
